<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Zheng Chen</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <meta name="author" content="Zheng Chen"/>
<link rel="stylesheet" href=style.css>
<meta name="thumbnail" content="images/zheng-chen-thumb.jpg" />

<link type="text/css" rel="stylesheet" href="index.css"/>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
</head>

<body>
  <nav>
    <ul>
        <li><a href="index.html">Home</a></li>
    </ul>
  </nav>

  <div id="blog-content">
    </div>
  
  <script id="markdown-source" type="text/markdown">
# My Great Adventure with RenderDoc

**Date:** 2025-11-20 | **Tags:** #ComputerGraphics #ComputerScience 

# 操作系统内存管理：碎片化与分页机制详解

这是操作系统内存管理中经典的 **Trade-off（权衡）**：分页机制彻底消灭了“外部碎片”，但作为代价，引入了少量的“内部碎片”。

## 1. 什么是外部碎片 vs 内部碎片？

我们可以用“停车场”来做比喻。

### 外部碎片 (External Fragmentation)
* **定义：** 内存中**总的**空闲空间足够满足分配请求，但这些空闲空间被**分散**在不同的角落，导致无法找到一块**足够大且连续**的区域来分配。
* **发生场景：** 分段（Segmentation） 或 动态分区分配。
* **比喻：** 停车场里总共有 5 个空车位，但这 5 个车位不连在一起（被别的车隔开了）。现在来了一辆加长林肯（需要连续 3 个车位），虽然总空位够（5 > 3），但这辆车却停不进去。
* **后果：** 必须进行**内存紧缩（Compaction）**，即把正在运行的程序挪动位置，把空隙拼在一起。但这极其消耗 CPU 资源，会让系统暂停。
* **分页的态度：** **分页彻底解决了这个问题**。因为分页允许程序分散存放，只要有 3 个空页框，不管它们在天涯海角，都能分配给程序。

### 内部碎片 (Internal Fragmentation)
* **定义：** 已经分配给进程的内存块中，有一部分空间没有被利用，被浪费在了**块的内部**。
* **发生场景：** 分页（Paging） 或 固定分区。
* **比喻：** 停车场的车位都是标准的“大巴车位”。现在来了一辆 Smart 微型车。它停进去后，车位里剩下的空间很大，但别的车不能停进来了（因为车位是分配的最小单位）。
* **原因：** 内存分配是按“页”（如 4KB）为单位的。如果一个程序只需要 1 字节，系统也必须给它分配整整 4KB。这剩下的 4095 字节就是内部碎片。
* **分页的态度：** 这是分页**无法避免的代价**。不过通常只发生在程序的最后一页，相较于内存总量，这个浪费通常是可以接受的（比如 8GB 内存浪费几 KB）。

---

## 2. 分页（Paging）系统总结

针对 CS 毕业生的背景，分页的优缺点和特点总结如下，适合面试或系统设计复习：

### 核心特点 (Key Characteristics)
* **离散分配 (Non-contiguous Allocation)：** 这是灵魂。逻辑上连续的地址，物理上可以是分散的。
* **逻辑与物理解耦：** 程序员/编译器只关心虚拟地址，操作系统/硬件负责映射到物理地址。
* **固定大小 (Fixed Size)：** 无论是虚拟空间的“页”还是物理空间的“页框”，大小必须一致（通常 4KB）。

### 优点 (Pros)
* **无外部碎片：** 内存利用率高，不需要进行昂贵的“内存紧缩”。
* **简化内存分配：** 操作系统不需要维护复杂的“最佳匹配/最差匹配”算法，只需要维护一个位图 (Bitmap) 或链表来记录哪些页框是空的，分配只需 $O(1)$ 或 $O(N)$ 的计数操作。
* **支持虚拟内存 (Virtual Memory)：** 能够运行比物理内存大得多的程序，支持按需加载（Demand Paging）。
* **便于共享与保护：** 可以在页表级别轻松实现共享库（.dll/.so）和权限控制（RWX bits）。

### 缺点 (Cons)
* **内部碎片：** 虽然不大，但依然存在（平均每个进程浪费半页大小）。
* **内存开销 (Memory Overhead)：** **页表本身需要占用内存**。
    * *计算：* 32位系统，4KB一页，大概需要 100万个页表项。每个项 4字节，这就需要 4MB 内存。如果是 64位系统，单级页表会大到无法接受（所以才有了多级页表）。
* **性能开销 (Performance Overhead)：** 每次内存访问都需要进行地址转换（逻辑 -> 物理），如果 TLB 未命中，性能会显著下降。

---

## 3. 直观对比总结表

| 特性 | 分页 (Paging) | 分段 (Segmentation) |
| :--- | :--- | :--- |
| **分配单位** | 固定大小的页 (Page) | 变长的段 (Segment) |
| **物理连续性** | 不需要 | 需要 |
| **碎片类型** | **内部碎片** (最后一页浪费) | **外部碎片** (内存中有空洞) |
| **主要目的** | 提高内存利用率，实现虚拟内存 | 符合逻辑结构，方便编码和保护 |
| **对程序员可见性** | **透明** (程序员感知不到页的存在) | **可见** (程序员知道代码段、数据段) |


# 为什么多级页表能节省内存空间？

很多初学者都被困在这里：**既然映射范围是一样的（都是 0~4GB），凭什么多了一层结构，页表反而变小了？**

答案的核心在于一个词：**稀疏性 (Sparsity)**。

多级页表之所以能省空间，是因为**它不需要为“不存在的内存”建立索引**，而单级页表（数组）必须建立。

---

## 1. 直觉陷阱：数组的死板 (Single-level Page Table)

假设你的虚拟地址空间是 `0 ~ 9999`（为了简单，假设只有 1万 个地址）。
你的程序非常小，只用了 **0号** 地址和 **9999号** 地址（比如代码在头，栈在尾）。

### 如果是单级页表：
单级页表是一个**数组**。数组有一个致命的特性：**下标必须连续**。
为了能访问到 `arr[9999]`，你必须声明一个长度为 10000 的数组。

* `Entry[0]` = **有效**
* `Entry[1]` ~ `Entry[9998]` = **空 (NULL)**
    * *重点在这里！你必须把这 9998 个空位存下来，虽然它们没用，但必须占位。*
* `Entry[9999]` = **有效**

**结论：** 即便你只用了 2 个页，你也必须占用 **10000 个页表项**的空间。

---

## 2. 多级页表的魔法：树的修剪 (Multi-level Page Table)

多级页表本质上是一个**树**（或者说目录结构）。树的特性是：**如果某个分支是空的，我就不需要创建那个分支的节点**。

我们把这 10000 个地址分成两级：
* **顶级目录（覆盖范围）：** 每一项负责管理 100 个地址。所以需要 100 个目录项。
    * 目录项 0：负责 0~99
    * 目录项 1：负责 100~199
    * ...
    * 目录项 99：负责 9900~9999

### 现在同样只用 0 号和 9999 号地址：

1.  **创建顶级目录：** 这个必须全要有（100 项）。
    * `Dir[0]` -> 指向 **二级页表 A**
    * `Dir[1]` ~ `Dir[98]` -> **NULL (空指针)**
        * *重点：这里是空的，所以我根本不需要创建对应的二级页表！*
    * `Dir[99]` -> 指向 **二级页表 B**

2.  **创建二级页表：**
    * **只创建** 二级页表 A（负责 0~99）：里面填好 0 号地址。
    * **只创建** 二级页表 B（负责 9900~9999）：里面填好 9999 号地址。

### 算一算现在的开销：
顶级目录（100项） + 二级表 A（100项） + 二级表 B（100项） = **300 项**。

### 对比结果：
* **单级页表：** 10000 项。
* **多级页表：** 300 项。
* **表示能力：** 两者都能覆盖 `0 ~ 9999` 的范围。

---

## 3. 现实世界的例子 (32位系统)

在真实的 32 位系统中，虚拟地址空间是 **4GB**。
一个典型的进程（比如简单的 Hello World）可能只用了 **10MB** 内存。

* **虚拟空间总量：** 4GB
* **实际使用量：** 10MB
* **稀疏度：** 99.75% 的地址空间是空的！

### 如果用单级页表：
它不管你用没用，为了覆盖这 4GB 范围，它必须连续铺开 **100万个页表项**。
* **内存占用：4MB**（实打实的物理内存，且必须连续）。

### 如果用二级页表：
1.  **一级目录：** 必须有，占用 **4KB**。
2.  **二级页表：** 10MB 数据大约需要 3 个二级页表（每个覆盖 4MB）。所以只创建 3 个二级页表。
    * 占用：$3 \times 4KB = 12KB$。
3.  **中间的空洞：** 剩下的 1021 个目录项都是空的，对应的 1021 个二级页表根本就不存在，不占用内存。

* **总内存占用：** 4KB + 12KB = **16KB**。

### 最终比分：4MB vs 16KB

---

## 总结

多级页表能省空间的根本原因是：**大部分程序的虚拟地址空间是非常“稀疏”的（Sparse）。**

> **形象比喻：**
>
> * **单级页表**就像一本**字典**。即使你只查“A”和“Z”开头的单词，你也必须把 B~Y 开头的空白页也都装订在书里，因为页码必须连续。
> * **多级页表**就像一个**活页夹**。你只有“A”和“Z”的内容，你就只往里面插这两页纸。虽然活页夹的封皮（顶级目录）写着它能装下 A-Z，但实际上你没装的部分就不占厚度。

**反之：** 如果你的程序真的把 4GB 内存**全部填满**了，那么多级页表反而会比单级页表**更大**（因为多存了一级目录）。但这在现实中几乎不可能发生（物理内存通常都没这么大）。
  </script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <script>
    marked.setOptions({
        highlight: (code, lang) => {
            const language = hljs.getLanguage(lang) ? lang : 'plaintext';
            return hljs.highlight(code, { language }).value;
        },
        langPrefix: 'hljs language-'
    });

    const markdownText = document.getElementById('markdown-source').textContent;

    document.getElementById('blog-content').innerHTML = marked.parse(markdownText);
  </script>

  <a href="blog.html">back</a>
</body>
</html>

