<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Zheng Chen</title>
  <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  <meta name="author" content="Zheng Chen"/>
<link rel="stylesheet" href=style.css>
<meta name="thumbnail" content="images/zheng-chen-thumb.jpg" />

<link type="text/css" rel="stylesheet" href="blog.css"/>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
</head>

<body>
  <nav>
    <ul>
        <li><a href="../index.html">Home</a></li>
    </ul>
  </nav>

  <div id="blog-content">
    </div>
  
  <script id="markdown-source" type="text/markdown">
# Introduction to Deferred Rendering

**Date:** 2025-11-25 | **Tags:** #ComputerGraphics

##  Contents

* [Introduction: Why deferred rendering?](#why-deferred-rendering)
* [Core: How does deferred rendering work?](#how-deferred-rendering-works)
* [Advantages and Challenges](#advantages-and-challenges)
* [Modern Variants and Optimizations](#modern-variants-and-optimizations)

## Why deferred rendering?

Consider the following two oversimplified ways to render a 3D scene:

First:

```
for object in objects:
    for light in lights:
        draw(mesh, light)
```

Second:

```
for object in objects:
    draw_to_bufferA(object)

for light in lights:
    draw_to_bufferB(light)

draw(bufferA, bufferB)

```
The first approach is called forward rendering, while the second is deferred rendering. In real applications, the GPU is dealing with "triangles" instead of "objects," but we use this simplified loop structure to illustrate the algorithmic difference.

It is easy to see that the first algorithm has a time complexity of $O(m \times n)$, where $m$ is the number of objects and $n$ is the number of lights, while the second algorithm has a time complexity of $O(m+n)$. So, for algorithm efficiency, deferred rendering is significantly better when there are many lights in the scene.

Also, in forward rendering, there may be pixels that are drawn multiple times due to overlapping objects, leading to wasted computation on shading. This issue is often called "overdraw". Deferred rendering avoids overdraw on the lighting step by deferring the lighting calculations until it has a fair understanding of the geometry in the scene.


## Core: How does deferred rendering works?

A complete deferred rendering pipeline looks like this:

Deferred rendering is a two-pass pipeline, designed to decouple geometry processing from lighting calculation.

The main steps are:
1. **Geometry Pass**: In this pass, the scene's geometry information is calculated and stored in Gbuffers(guess what "G" stands for). These buffers typically include position, normal, albedo(color), and specular information for each pixel.
2. **Lighting Pass**: In this pass, the lighting calculations are performed using the data from the Gbuffers. Each light source is processed, and its contribution to the final pixel color is computed based on the stored geometry information.

---

  </script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <script>
    marked.setOptions({
        highlight: (code, lang) => {
            const language = hljs.getLanguage(lang) ? lang : 'plaintext';
            return hljs.highlight(code, { language }).value;
        },
        langPrefix: 'hljs language-'
    });

    const markdownText = document.getElementById('markdown-source').textContent;

    document.getElementById('blog-content').innerHTML = marked.parse(markdownText);
  </script>

  <a href="../blog.html">back</a>
</body>
</html>

